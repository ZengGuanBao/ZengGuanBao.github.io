{"meta":{"title":"ZengGuanBao的博客","subtitle":null,"description":"这是本人搜集及个人心得体会的笔记","author":"ZengGuanBao","url":"https://zengguanbao.github.io"},"pages":[{"title":"个人简介","date":"2018-10-17T09:56:22.670Z","updated":"2018-10-17T09:56:22.670Z","comments":true,"path":"about/index.html","permalink":"https://zengguanbao.github.io/about/index.html","excerpt":"","text":"作者：ZengGuanBao 出处：http://zengguanbao.github.io/ 本文基于知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名ZengGuanBao及链接。"},{"title":"Demo展示","date":"2019-04-23T06:19:56.668Z","updated":"2019-04-23T06:19:56.668Z","comments":true,"path":"demo/index.html","permalink":"https://zengguanbao.github.io/demo/index.html","excerpt":"","text":"js实现星级评分点击效果音乐播放器"},{"title":"","date":"2019-04-23T06:32:41.315Z","updated":"2019-04-23T06:32:41.315Z","comments":true,"path":"demo/star.html","permalink":"https://zengguanbao.github.io/demo/star.html","excerpt":"","text":"js实现星级评分点击效果 * { margin: 0; padding: 0; list-style-type: none; } body { color: #666; font: 12px/1.5 Arial; } /* star */ #star { position: relative; width: 600px; margin: 20px auto; height: 24px; } #star ul, #star span { float: left; display: inline; height: 19px; line-height: 19px; } #star ul { margin: 0 10px; } #star li { float: left; width: 24px; cursor: pointer; text-indent: -9999px; background: url(images/star.png) no-repeat; } #star strong { color: #f60; padding-left: 10px; } #star li.on { background-position: 0 -28px; } #star p { position: absolute; top: 20px; width: 159px; height: 60px; display: none; background: url(images/icon.gif) no-repeat; padding: 7px 10px 0; } #star p em { color: #f60; display: block; font-style: normal; } 1 2 3 4 5 window.onload = function () { var oStar = document.getElementById(\"star\"); var aLi = oStar.getElementsByTagName(\"li\"); var oUl = oStar.getElementsByTagName(\"ul\")[0]; var oSpan = oStar.getElementsByTagName(\"span\")[1]; var oP = oStar.getElementsByTagName(\"p\")[0]; var i = iScore = iStar = 0; var aMsg = [ \"很不满意|差得太离谱，与卖家描述的严重不符，非常不满\", \"不满意|部分有破损，与卖家描述的不符，不满意\", \"一般|质量一般，没有卖家描述的那么好\", \"满意|质量不错，与卖家描述的基本一致，还是挺满意的\", \"非常满意|质量非常好，与卖家描述的完全一致，非常满意\" ] for (i = 1; i"}],"posts":[{"title":"详解ES5和ES6的继承","slug":"详解ES5和ES6的继承","date":"2019-05-07T01:58:09.340Z","updated":"2019-05-14T09:32:54.372Z","comments":true,"path":"2019/05/07/详解ES5和ES6的继承/","link":"","permalink":"https://zengguanbao.github.io/2019/05/07/详解ES5和ES6的继承/","excerpt":"","text":"##详解ES5和ES6的继承ES5继承构造函数、原型和实例的关系：每一个构造函数都有一个原型对象，每一个原型对象都有一个指向构造函数的指针，而每一个实例都包含一个指向原型对象的内部指针， 原型链实现继承 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个类型的实例 基本模式： function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } \\\\继承了SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function(){ return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); \\\\true 最终结果：instance指向SubType的原型，SubType的原型又指向SuperType的原型，getSuperValue()方法任然在SuperType.prototype中，但property则位于SubType.prototype中，这是因为property是一个实例属性，而getSuperValue是一个原型方法。此时，instance.constructor指向的是SuperType。 注意事项： 别忘记默认的原型，所有的引用类型都继承自Object，所有函数的默认原型都是Object的实例，因此默认原型里都有一个指针，指向object.prototype 谨慎地定义方法，给原型添加方法的代码一定要放在替换原型的语句之后，不能使用对象字面量添加原型方法，这样会重写原型链 原型链继承的问题 最主要的问题来自包含引用类型值的原型，它会被所有实例共享 第二个问题是，创造子类型的实例时，不能向超类型的构造函数中传递参数 借用构造函数 基本思想：在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法可以在将来新创建的对象上执行构造函数 function SuperType(){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; } ​ function SubType(){ \\\\借调了超类型的构造函数 SuperType.call(this); } ​ var instance1 = new SubType(); \\\\[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;] instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); ​ var instance2 = new SubType(); \\\\[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] console.log(instance2.colors); 通过call或者apply方法，我们实际上是在将来新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType函数中定义的所有对象初始化代码，因此，每一个SubType的实例都会有自己的colors对象的副本 优势： 传递参数 function Supertype(name){ this.name = name; } ​ function Subtype(){ Supertype.call(this,&apos;Annika&apos;); this.age = 21; } ​ var instance = new Subtype; console.log(instance.name); \\\\Annika console.log(instance.age); \\\\29 缺点： 方法都在构造函数中定义，函数无法复用 在超类型中定义的方法，子类型不可见，结果所有类型都只能使用构造函数模式 组合继承 基本思想：将原型链和借用构造函数技术组合到一起。使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性 function Supertype(name){ this.name = name; this.colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]; } ​ Supertype.prototype.sayName = function(){ console.log(this.name); }; ​ function Subtype(name,age){ \\\\继承属性 Supertype.call(this,name); this.age = age; } ​ \\\\继承方法 Subtype.prototype = new Supertype(); Subtype.prototype.constructor = Subtype; Subtype.prototype.sayAge = function(){ console.log(this.age); }; ​ var instance1 = new Subtype(&apos;Annika&apos;,21); instance1.colors.push(&quot;black&quot;); \\\\[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;] console.log(instance1.colors); instance1.sayName(); \\\\Annika instance1.sayAge(); \\\\21 ​ var instance2 = new Subtype(&apos;Anna&apos;,22); \\\\[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] console.log(instance2.colors); instance2.sayName(); \\\\Anna instance2.sayAge(); \\\\22 缺点：无论在什么情况下，都会调用两次超类型构造函数，一次是在创建子类型原型的时候，一次是在子类型构造函数的内部 原型式继承 基本思想：不用严格意义上的构造函数，借助原型可以根据已有的对象创建新对象，还不必因此创建自定义类型，因此最初有如下函数： function object(o){ function F(){} F.prototype = o; return new F(); } 从本质上讲，object()对传入其中的对象执行了一次浅复制 var person = { name:&apos;Annika&apos;, friendes:[&apos;Alice&apos;,&apos;Joyce&apos;] }; ​ var anotherPerson = object(person); anotherPerson.name = &apos;Greg&apos;; anotherPerson.friendes.push(&apos;Rob&apos;); ​ var yetAnotherPerson = object(person); yetAnotherPerson.name = &apos;Linda&apos;; yetAnotherPerson.friendes.push(&apos;Sophia&apos;); ​ console.log(person.friends); //[&apos;Alice&apos;,&apos;Joyce&apos;,&apos;Rob&apos;,&apos;Sophia&apos;] 在这个例子中，实际上相当于创建了person的两个副本。 ES5新增Object.create规范了原型式继承，接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象，在传入一个参数的情况下，Object.create()和object()行为相同。 var person = { name:&apos;Annika&apos;, friendes:[&apos;Alice&apos;,&apos;Joyce&apos;] }; ​ var anotherPerson = object.create(person,{ name:{ value:&quot;Greg&quot; } }); ​ \\\\用这种方法指定的任何属性都会覆盖掉原型对象上的同名属性 console.log(anotherPerson.name); \\\\Greg 用处：创造两个相似的对象，但是包含引用类型的值的属性始终会共享响应的值 寄生式继承 基本思想：寄生式继承是与原型式继承紧密相关的一种思路，它创造一个仅用于封装继承过程的函数，在函数内部以某种方式增强对象，最后再返回对象。 function createAnother(original){ \\\\通过调用函数创建一个新对象 var clone = object(original); \\\\以某种方式来增强对象 clone.sayHi = fuuction(){ alert(&quot;Hi&quot;); }; \\\\返回这个对象 return clone } 缺点：使用寄生式继承来为对象添加函数，会因为做不到函数复用而降低效率，这个与构造函数模式类似 寄生组合式继承 基本思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，不必为了指定子类型的原型而调用超类型的构造函数，只需要超类型的一个副本。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型 function inheritPrototype(Subtype,supertype){ var prototype = object(supertype); \\\\创建对象 prototype.constructor = subtype; \\\\增强对象 subtype.prototype = prototype; \\\\指定对象 } 因此，前面的例子可以改为如下的形式 function Supertype(name){ this.name = name; this.colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]; } ​ Supertype.prototype.sayName = function(){ console.log(this.name); }; ​ function Subtype(name,age){ \\\\继承属性 Supertype.call(this,name); this.age = age; } ​ \\\\继承方法 inheritPrototype(Subtype,Supertype); ​ Subtype.prototype.sayAge = function(){ console.log(this.age); }; 优点：只调用了一次supertype构造函数，因此避免在subtype.prototype上创建不必要的，多余的属性，与此同时，原型链还能保持不变，还能正常使用instanceof 和isPrototypeOf()，因此，寄生组合式继承被认为是引用类型最理想的继承范式。 ES5的继承可以用下图来概括： ES6继承 es6的继承主要要注意的是class的继承。 基本用法：Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多 class Colorpoint extends Point { constructor(x,y,color){ super(x,y); //调用父类的constructor(x,y) this.color = color } toString(){ //调用父类的方法 return this.color + &apos; &apos; + super.toString(); } } 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。因此，只有调用super之后，才可以使用this关键字。 prototype 和proto 一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法的继承 class A extends B{} A.__proto__ === B; //继承属性 A.prototype.__proto__ == B.prototype;//继承方法 总结：ES6的继承可以用下图来概括：","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"https://zengguanbao.github.io/tags/ES5/"},{"name":"ES6","slug":"ES6","permalink":"https://zengguanbao.github.io/tags/ES6/"},{"name":"继承","slug":"继承","permalink":"https://zengguanbao.github.io/tags/继承/"}]},{"title":"Git-最简单的本地项目变成版本仓库，然后把内容推送到GitHub仓库","slug":"Git-最简单的本地项目变成版本仓库，然后把内容推送到GitHub仓库","date":"2019-04-30T01:48:33.376Z","updated":"2019-05-14T09:39:06.367Z","comments":true,"path":"2019/04/30/Git-最简单的本地项目变成版本仓库，然后把内容推送到GitHub仓库/","link":"","permalink":"https://zengguanbao.github.io/2019/04/30/Git-最简单的本地项目变成版本仓库，然后把内容推送到GitHub仓库/","excerpt":"","text":"工具：Visual Studio Code技术：Github ###Git-最简单的本地项目变成版本仓库，然后把内容推送到GitHub仓库（注：本文的前提是本地Git仓库和github仓库之间已经存在SSH key了，所以如果没有建立联系的小伙伴们请先建立联系） 具体操作： 一：把本地项目变成版本仓库1、把本地的一个项目目录编程版本库repository，例如下图，我把我E盘&gt;A课件&gt;大三2&gt;VUE.JS 变成一个版本库。 通过命令 git init 可以吧一个目录变成git管理仓库 2、通过命令git add -A把VUE.JS目录下的所有文件添加到暂存区里面去，git add 可以都很多用法，git add -A只是其中一个，作用是把目录中所有的文件信息添加到索引库的暂存区里面去。注意‘-A’大小写敏感哦，git add -a是失败的哦。 3、通过命令git commit 把刚刚提交到暂存区里的文件提交到仓库。git commit -m “提交所有文件”，-m 后面的文字是注释，方便查看历史记录时知道每一次提交提交的是什么。这一步成功之后，说明本地的项目已经用git版本器管理起来了，接下里就是如何把git本地仓库的内容推送到github仓库去了 二：把本地仓库的内容推送到github仓库去 1、登录github，然后按照下图的步骤Create 一个新的仓库。（博主是个英语渣还好有有道） 2、创建完成之后，这时在github上，仓库还是空的，然后我们目前要做的就是把一个已有的本地仓库与github关联，然后，把本地仓库的内容推送到GitHub仓库。 我们根据GitHub的提示，在本地的VUE.JS仓库下运行命令，如下图： git remote add origin https://github.com/SugarTiger/VueTest.git （红字这个地址是我的，你们填上你们自己的）,然后通过命令git push把本地仓库的内容推送到github仓库去。第一次推送在git push后面加上参数-u，使用-u选项指定一个默认主机。 $ git push -u origin master 3、最后就可以在github上面查看到刚刚push上去的项目内容了 解决每次输入用户名及密码问题git config –global credential.helper store","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"}]},{"title":"微信小程序入门教程实例讲解","slug":"微信小程序入门教程实例讲解","date":"2019-04-30T01:44:51.589Z","updated":"2019-05-14T09:49:48.907Z","comments":true,"path":"2019/04/30/微信小程序入门教程实例讲解/","link":"","permalink":"https://zengguanbao.github.io/2019/04/30/微信小程序入门教程实例讲解/","excerpt":"","text":"工具：Visual Studio Code/微信WEB开发者工具技术：小程序","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://zengguanbao.github.io/tags/小程序/"}]},{"title":"","slug":"个人前端知识体系详解","date":"2019-04-28T01:39:29.583Z","updated":"2019-04-28T08:23:39.266Z","comments":true,"path":"2019/04/28/个人前端知识体系详解/","link":"","permalink":"https://zengguanbao.github.io/2019/04/28/个人前端知识体系详解/","excerpt":"","text":"#JavaScript基础#JavaScript规定了2中语言类型: 原始（Primitive）类型：原始类型存储的是值 Undefined、Null、Boolean、String、Number、Symbol 对象（Object）类型：对象类型存储的是地址（指针） Object typeof vs instanceof 判断类型 typeof 对于原始类型来说，除了 null 都可以显示正确的类型 typeof 对于对象来说，除了函数都会显示 object instanceof，内部机制是通过原型链来判断的 instanceof 判断原始类型方法 class PrimitiveString { static [Symbol.hasInstance](x) { return typeof x === &apos;string&apos; } } console.log(&apos;hello world&apos; instanceof PrimitiveString) // true 类型转换 转换为布尔值 转换为数字 转换为字符串 闭包闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。 装箱和拆箱装箱转换：基本类型–&gt;对象 每一种基本类型，都在对象中有对应的类，装箱机制会频繁产生临时对象。 使用object函数，可以显示调用装箱能力。 每一类装箱对象皆有私有的 Class 属性，这些属性可以Object.prototype.toString 获取。在 JavaScript 中，没有任何方法可以更改私有的Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。 call函数本身会产生装箱操作，需要配合typeof来区分基本类型还是对象类型。 拆箱转换：对象–&gt;基本类型 对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下： 如果已经是原始类型了，那就不需要转换了 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回原始类型，就会报错 let a = { valueOf() { return 0 }, toString() { return &apos;1&apos; }, [Symbol.toPrimitive]() { return 2 } } 1 + a // =&gt; 3 当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。 vue框架知识生命周期钩子函数 在beforeCreate钩子函数调用的时候，是获取不到props或者data中的数据的，因为这些数据的初始化都在initState中。 然后执行create的钩子函数，这个时候可以访问到之前访问不到的数据，但是这个时候组件没有被挂载，所以看不到。 接下来会执行beforeMount的钩子函数，开始创建VDOM，最后执行mounted钩子，并将VDOM渲染为真实的DOM并且渲染数据。组件中如果有子组件的话，会递归挂载组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。 接下来是数据更新时会调用的钩子函数beforeUpdate和updated。 另外还有keep-alive独有的生命周期，分别为activated和deactivated。用keep-alive包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行deactivated钩子函数，命中缓存渲染后会执行activated钩子函数。 最后就是销毁组件的钩子函数beforeDestroy和destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。 组件通信组件通信一般分为以下几种情况： 父子组件通信：父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法 兄弟组件通信：对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。 跨多层级组件通信：对于这种情况可以使用 Vue 2.2 新增的 API provide / inject // 父组件 A export default { provide: { data: 1 } } // 子组件 B export default { inject: [&apos;data&apos;], mounted() { // 无论跨几层都能获得父组件的 data 属性 console.log(this.data) // =&gt; 1 } } 任意组件：这种方式可以通过 Vuex 或者 Event Bus 解决 extend：作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。 // 创建组件构造器 let Component = Vue.extend({ template: &apos;&lt;div&gt;test&lt;/div&gt;&apos; }) // 挂载到 #app 上 new Component().$mount(‘#app’) // 除了上面的方式，还可以用来扩展已有的组件 let SuperComponent = Vue.extend(Component) new SuperComponent({ created() { console.log(1) } }) new SuperComponent().$mount(‘#app’) mixin 和 mixins 区别mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。 Vue.mixin({ beforeCreate() { // ...逻辑 // 这种方式会影响到每个组件的 beforeCreate 钩子函数 } }) 虽然文档不建议我们在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。 mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。 ###computed 和 watch一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。 vm.$watch(&apos;obj&apos;, { // 深度遍历 deep: true, // 立即触发 immediate: true, // 执行的函数 handler: function(val, oldVal) {} }) var vm = new Vue({ data: { a: 1 }, computed: { aPlus: { // this.aPlus 时触发 get: function () { return this.a + 1 }, // this.aPlus = 1 时触发 set: function (v) { this.a = v - 1 } } } }) ###响应式原理","categories":[],"tags":[]},{"title":"HTML5-WebSocket","slug":"HTML5-WebSocket","date":"2019-04-25T01:20:45.625Z","updated":"2019-04-30T02:18:45.177Z","comments":true,"path":"2019/04/25/HTML5-WebSocket/","link":"","permalink":"https://zengguanbao.github.io/2019/04/25/HTML5-WebSocket/","excerpt":"","text":"工具：Visual Studio Code技术：HTML5-WebSocket","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"HTML5-WebSocket","slug":"HTML5-WebSocket","permalink":"https://zengguanbao.github.io/tags/HTML5-WebSocket/"}]},{"title":"移动端开发中的meta/css/@media","slug":"移动端开发","date":"2019-04-23T02:33:44.691Z","updated":"2019-04-30T02:20:11.015Z","comments":true,"path":"2019/04/23/移动端开发/","link":"","permalink":"https://zengguanbao.github.io/2019/04/23/移动端开发/","excerpt":"","text":"移动开发中头部要加的一些常用meta&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0,user-scalable=no,maxinum-scale=1,width=device-width&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta name=&quot;applicable-device&quot; content=&quot;mobile&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;&gt; css3 @media媒体查询适应不同的手机iphone 4和4s@media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-min-device-pixel-ratio:2){} iphone 5 and 5s@media only screen and (min-device-width:320px) and (max-device-width:568px) and (-webkit-min-device-pixel-ratio:2){} Android width360@media only screen and (min-device-width:360px) and (max-device-width:640px){ html {font-size:112.5px;} } android width411@media only screen and (min-device-width:400px){ html {font-size:128.4375px;} } iphone 6@media only screen and (min-device-width:375px) and (max-device-width:667px) and (-webkit-min-device-pixel-ratio:2){ html {font-size:129.375px;} } iphone 6+@media only screen and (min-device-width:375px) and (max-device-width:667px) and (-webkit-min-device-pixel-ratio:2){ html {font-size:117.1875px;} } 初始化css*{ -webkit-tap-highlight-color:transparent;outline:0;margin:0;padding:0;vertical-align:baseline;fone-size:inherit;line-height:inherit;} body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,li,pre,form,field,legend,button,input,textarea,th,td{margin:0,padding:0,vertical-align:baseline;} i,em{font-style:normal;} ol,ul{list-style:none;} h1,h2,h3,h4,h5,h6,strong,b{font-weight:normal;} input,select,button,h1,h2,h3,h4,h5,h6{font-size:inherit;font-family:inherit;} table{border-collapse:collapse;border-spacing:0;} a{text-decoration:none;color:#666;} body{margin:0 auto;min-width:320px;max-width:640px;height:100%;font-family:Microsoft Yahei,Helvetica;line-height:1.5;color:#666;-webkit-text-size-adjust:100%!importtant;text-size-adjust:100% !important;} textarea{resize:none;} input[type=&quot;text&quot;],input[type=&quot;tel&quot;],input[type=&quot;button&quot;],textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:nione;} body{font-size:0.14rem;-webkit-overflow-scrolling:touch;} html{box-sizing:border-box;font-size:100px;height:100%;-webkit-text-size-adjust:none} *,*:before,*:after{content:&quot;020&quot;,display:block;height:0;overflow:hidden;clear:both}","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"}]},{"title":"JavaScript学习笔记","slug":"js学习笔记","date":"2019-03-14T01:42:20.803Z","updated":"2019-04-23T03:12:35.619Z","comments":true,"path":"2019/03/14/js学习笔记/","link":"","permalink":"https://zengguanbao.github.io/2019/03/14/js学习笔记/","excerpt":"","text":"工具：Visual Studio Code/MarkdownPad技术：JavaScript ##JavaScript类型 ###基本类型有六种： null，undefined，boolean，number，string，symbol ###typeof 对于基本类型，除了 null 都可以显示正确的类型 typeof 1 // ‘number’ typeof ‘1’ // ‘string’ typeof undefined // ‘undefined’ typeof true // ‘boolean’ typeof Symbol() // ‘symbol’ typeof b // b 没有声明，但是还会显示 undefined ###想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。 console.log(Object.prototype.toString.call(“jerry”));//[object String] console.log(Object.prototype.toString.call(12));//[object Number] console.log(Object.prototype.toString.call(true));//[object Boolean] console.log(Object.prototype.toString.call(undefined));//[object Undefined] console.log(Object.prototype.toString.call(null));//[object Null] console.log(Object.prototype.toString.call({name: “jerry”}));//[object Object] console.log(Object.prototype.toString.call(function(){}));//[object Function] console.log(Object.prototype.toString.call([]));//[object Array] console.log(Object.prototype.toString.call(new Date));//[object Date] console.log(Object.prototype.toString.call(/\\d/));//[object RegExp] function Person(){}; console.log(Object.prototype.toString.call(new Person));//[object Object] ###js中的instanceof运算符 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 语法：obj instanceof Object;//true 实例obj在不在Object构造函数中 instanceof的普通的用法，obj instanceof Object 检测Object.prototype是否存在于参数obj的原型链上。Person的原型在p的原型链中 function Person(){}; var p =new Person(); console.log(p instanceof Person);//true 继承中判断实例是否属于它的父类Student和Person都在s的原型链中 function Person(){}; function Student(){}; var p =new Person(); Student.prototype=p;//继承原型 var s=new Student(); console.log(s instanceof Student);//true console.log(s instanceof Person);//true 复杂用法，这里的案例要有熟练的原型链的认识才能理解 function Person() {} console.log(Object instanceof Object); //true //第一个Object的原型链：Object=&gt; //Object.__proto__ =&gt; Function.prototype=&gt;Function.prototype.__proto__=&gt;Object.prototype //第二个Object的原型：Object=&gt; Object.prototype console.log(Function instanceof Function); //true //第一个Function的原型链：Function=&gt;Function.__proto__ =&gt; Function.prototype //第二个Function的原型：Function=&gt;Function.prototype console.log(Function instanceof Object); //true //Function=&gt; //Function.__proto__=&gt;Function.prototype=&gt;Function.prototype.__proto__=&gt;Object.prototype //Object =&gt; Object.prototype console.log(Person instanceof Function); //true //Person=&gt;Person.__proto__=&gt;Function.prototype //Function=&gt;Function.prototype console.log(String instanceof String); //false //第一个String的原型链：String=&gt; //String.__proto__=&gt;Function.prototype=&gt;Function.prototype.__proto__=&gt;Object.prototype //第二个String的原型链：String=&gt;String.prototype console.log(Boolean instanceof Boolean); //false //第一个Boolean的原型链：Boolean=&gt; //Boolean.__proto__=&gt;Function.prototype=&gt;Function.prototype.__proto__=&gt;Object.prototype //第二个Boolean的原型链：Boolean=&gt;Boolean.prototype console.log(Person instanceof Person); //false //第一个Person的原型链：Person=&gt; //Person.__proto__=&gt;Function.prototype=&gt;Function.prototype.__proto__=&gt;Object.prototype //第二个Person的原型链：Person=&gt;Person.prototype 总结对应上述规范做个函数模拟A instanceof B： function _instanceof(A, B) { var O = B.prototype;// 取B的显示原型 A = A.__proto__;// 取A的隐式原型 while (true) { //Object.prototype.__proto__ === null if (A === null) return false; if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true return true; A = A.__proto__; } } ###对象中的原型方法首先会调用 valueOf 然后调用 toString，Symbol.toPrimitive （该方法在转基本类型时调用优先级最高），方法你是可以重写的 let a = { valueOf() { return 0; }, toString() { return ‘1’; }, Symbol.toPrimitive { return 2; } } 1 + a // =&gt; 3 ‘1’ + a // =&gt; ‘12’","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zengguanbao.github.io/tags/JavaScript/"}]},{"title":"IE中使用ajax碰到的问题","slug":"IE中使用ajax碰到的问题","date":"2018-11-06T09:23:21.759Z","updated":"2019-04-23T03:12:31.741Z","comments":true,"path":"2018/11/06/IE中使用ajax碰到的问题/","link":"","permalink":"https://zengguanbao.github.io/2018/11/06/IE中使用ajax碰到的问题/","excerpt":"","text":"##IE中的crossDomain=true属性设置再ajax请求过程中设置了crossDomain=true属性，再谷歌内核中是可以正确解读为support.cors = true，发现其他浏览器中都是support.cors = true，唯独在IE中support.cors = false，这个属性的判断来自于support.cors = !!xhrSupported &amp;&amp; ( “withCredentials” in xhrSupported )，其中xhrSupported= new window.XMLHttpRequest(),ie9中XMLHttpRequest没有withCredentials属性。也就是说这个问题是由于我的乱用属性加上各浏览器兼容性问题而导致的。 ##解决方法 解决ajax时出现No Transport，在使用ajax之前添加：jQuery.support.cors = true;//浏览器支持跨域访问 加载jquery-ajaxtransport-xdomainrequest的js1&lt;!--[if lte IE 9]&gt;&lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/jquery-ajaxtransport-xdomainrequest/1.0.3/jquery.xdomainrequest.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; ##意外的问题遇到一个问题就是写的js在客户生产环境中的ie和360中不起作用，随后我想看看浏览器的输出，并没有异常错误，然后继续操作发现一个奇怪的现象就是，在开启F12的情况下，功能正常使用，一旦关闭则使用不了，上网找了资料，参考了superGG1990的文章，在开发过程中，console.log常被用来调试程序，在Chrome和Firefox中友好运行，但是在IE9之前的版本支持不友好，IE6和IE7虽然可以安装 Developer Toolbar，但也不支持console。 解决方案：在开发完成过后删除打印的调试信息或者先判断一下js中的console是否存在 12345function log(msg)&#123; if (window[&quot;console&quot;])&#123; console.log(msg); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"},{"name":"hexo","slug":"hexo","permalink":"https://zengguanbao.github.io/tags/hexo/"}]},{"title":"使用Hexo+Github搭建属于自己的博客","slug":"hexo-build","date":"2018-10-12T03:00:09.114Z","updated":"2019-04-23T03:12:27.769Z","comments":true,"path":"2018/10/12/hexo-build/","link":"","permalink":"https://zengguanbao.github.io/2018/10/12/hexo-build/","excerpt":"","text":"工具：Visual Studio Code/MarkdownPad技术：Hexo+Github 创建Github项目 Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 安装Hexo 在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后在vscode打文件夹 在vscode中打开终端，输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。）看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo（假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号） 将本地blog和Github项目联系起来 配置Deployment，在其文件夹中，找到_config.yml文件，修改repository值（在末尾） repository值是你在github项目里的ssh（右下角） 1234deploy: type: git repository: git@github.com:ZengGuanBao/ZengGuanBao.github.io.git branch: master 新建一篇博客，在cmd执行命令：hexo new post “博客名”或者在vscode中新建文件 把新建的文章更新到Github项目上 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 更新主题后，上传没有生效最后，在查询了一些资料之后，终于知道，这可能是hexo的缓存的问题，也就是你网站根目录的那个db.json文件，还知道了一点，推荐在发布网站之前，先清除缓存，然后再部署网站。清除缓存的方法： 执行命令：hexo clean 然后可以生成静态博客并在本地预览：hexo d -g搜索功能 使用站内搜索，安装npm i -S hexo-generator-json-content 分享功能百度分享不支持Https的解决方案 将static文件夹放在网站的根目录下，并将对应的百度分享代码中，把http://bdimg.share.baidu.com/ 改为 /static/api/js/share.js?v=89860593.js? 123456789101112131415161718192021222324252627282930313233&lt;p&gt;&lt;i class=&quot;fa fa-share&quot;&gt;&lt;/i&gt;分享到&lt;/p&gt;&lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_linkedin&quot; data-cmd=&quot;linkedin&quot; title=&quot;分享到linkedin&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot; title=&quot;分享到微信&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_evernotecn&quot; data-cmd=&quot;evernotecn&quot; title=&quot;分享到印象笔记&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdSnsKey&quot;: &#123;&#125;, &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;2&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot;, &quot;bdStyle&quot;: &quot;1&quot;, &quot;bdSize&quot;: &quot;24&quot; &#125;, &quot;share&quot;: &#123;&#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;fbook&quot;, &quot;twi&quot;, &quot;linkedin&quot;, &quot;qzone&quot;, &quot;tsina&quot;, &quot;douban&quot;, &quot;weixin&quot;, &quot;evernotecn&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125; &#125;; with(document) 0[(getElementsByTagName(&apos;head&apos;)[0] || body).appendChild(createElement(&apos;script&apos;)).src = &apos;/static/api/js/share.js?v=89860593.js?&apos;];&lt;/script&gt; 评论功能评论功能使用的Valine 1234567891011121314151617&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&apos;//unpkg.com/valine/dist/Valine.min.js&apos;&gt;&lt;/script&gt;&lt;script&gt; new Valine(&#123; el: &apos;#valine-thread&apos; , notify: , verify: , app_id: &apos;&apos;, app_key: &apos;&apos;, placeholder: &apos;&apos;, pageSize: &apos;&apos;, avatar: &apos;&apos;, avatar_cdn: &apos;&apos;, visitor: &#125;);&lt;/script&gt;&lt;div id=&quot;valine-thread&quot;&gt;&lt;/div&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"},{"name":"hexo","slug":"hexo","permalink":"https://zengguanbao.github.io/tags/hexo/"}]},{"title":"克隆远程仓库并推送本地更新","slug":"克隆远程仓库并推送本地更新","date":"2018-05-23T08:41:11.305Z","updated":"2019-04-23T03:12:21.151Z","comments":true,"path":"2018/05/23/克隆远程仓库并推送本地更新/","link":"","permalink":"https://zengguanbao.github.io/2018/05/23/克隆远程仓库并推送本地更新/","excerpt":"","text":"克隆远程仓库并推送本地更新1.新建远程仓库（vueMusic） 2.克隆远程仓库 git clone git@github.com:ZengGuanBao/vueMusic.git 3.有更新的情况操作步骤 git status git add . git commit -m “文件提示” 4.再推送本地库到远程仓库 git push origin master","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"}]},{"title":"mac绑定git中的SSH密匙","slug":"mac绑定git中的ssh密匙","date":"2018-05-23T08:41:11.302Z","updated":"2019-04-23T03:12:19.963Z","comments":true,"path":"2018/05/23/mac绑定git中的ssh密匙/","link":"","permalink":"https://zengguanbao.github.io/2018/05/23/mac绑定git中的ssh密匙/","excerpt":"","text":"步骤1全局修改git的用户名和邮箱 git config –global user.name “ZengGuanBao” git config –global user.email 672280840@qq.com Mac显示隐藏系统文件 方法一：（快捷键） 打开Finder，同时按下三个组合键：Shift + Command + . 方法二：（终端操作，要重启Finder，没方法一快捷） 显示：defaults write com.apple.finder AppleShowAllFiles -bool true 隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false 步骤2###生成密钥 1.输入指令：ssh-keygen -t rsa -C “672280840@qq.com“，提示输入保存密钥路径，直接回车即可（三次默认回车）。 2.注：后面是自己的GitHub邮箱 ###查看密钥文件 1.Finder前往：~/.ssh，文件夹内会存在2个文件：id_rsa和id_rsa.pub。 ###复制公钥内容 1. 方法一：Finder打开id_rsa.pub文件，使用文本编辑器打开，复制里面所有文字内容。 2. 方法二：终端指令复制id_rsa.pub文件内容。 ###将公钥内容添加到GitHub 1. 打开GitHub网站进行登陆； 2. 到个人设置页Personal Settings； 3. 找到SSH and GPG keys； 4. 选择新建SSH key：new ssh key； 5. 填写和粘贴公钥内容（不含中文）。","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"}]},{"title":"安装 Git","slug":"安装git","date":"2018-05-23T08:41:11.297Z","updated":"2019-04-23T03:11:59.216Z","comments":true,"path":"2018/05/23/安装git/","link":"","permalink":"https://zengguanbao.github.io/2018/05/23/安装git/","excerpt":"","text":"安装 Git 在 Mac 上安装 在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 git 命令即可。 如果没有安装过命令行开发者工具，将会提示你安装。 如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 http://git-scm.com/download/mac。 在 Windows 上安装 简单的方法是安装 GitHub for Windows。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的 CRLF 设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 https://git-for-windows.github.io。 Git 版本管理 经验：本地登录SSH认证 首先进行本地SSH公钥的生成。打开git bash终端，键入：SSH-KEYGEN -T RSA -C “邮箱地址”这里的邮箱地址即为你的github账号邮箱。 执行前述命令后若成功则会提示在用户文件夹下生成了ssh公钥的文件。是否成功可以通过访问文件夹 .ssh 来确定，若有此文件夹则说明生成成功。 在资源管理器中打开这个.ssh文件夹，在它下面会看到两个文件，选择后缀名为.pub的文件并用记事本打开，复制这个文件中的所有内容。 打开浏览器登陆github，在自己的账户面板下找到SSH keys这一栏，打开后即会看到目前该账户下已进行过SSH认证的机器，选择Add SSH key之后，将前一步复制的内容粘贴至Key中，同时需要编辑一个Title来说明此Key认证的是哪一台机器，通常会使用计算机的名字。 保存后，回到git bash中，键入 ssh git@github.com进行连接认证，其中有一步会询问是否确定进行连接，需要键入yes。若认证成功后将会有如图所示的返回结果字样。 在完成认证后，即可将git上的开源项目或自己账号下的私有项目clone到本地。","categories":[{"name":"技术","slug":"技术","permalink":"https://zengguanbao.github.io/categories/技术/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://zengguanbao.github.io/tags/Github/"}]}]}